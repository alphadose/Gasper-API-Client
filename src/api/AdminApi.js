/**
 * Gasper Dominus API
 * API specs for Gasper Dominus, the ecosystem's master. Handles authentication, creation/management of applications and databases and also provides a superuser API. The superuser API is only available for those user accounts which has `is_admin` set to `true` in the mongoDB database used by Gasper. Apart from that, a default superuser is created every time a Gasper instance is launched whose  credentials are defined in the `admin` section of `config.toml`, the main configuration file. A sample configuration file is available in the [Gasper GitHub Repository](https://github.com/sdslabs/gasper) under the name of `config.sample.toml`.<br><br> **Note:-** Normally the applications and databases can only be managed by their owners but the superuser can bypass that check.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: contact@sdslabs.co.in
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import InlineResponse2002 from '../model/InlineResponse2002';
import InlineResponse2003 from '../model/InlineResponse2003';
import InlineResponse2006 from '../model/InlineResponse2006';
import InlineResponse2007 from '../model/InlineResponse2007';
import InlineResponse2008 from '../model/InlineResponse2008';
import InlineResponse2009 from '../model/InlineResponse2009';
import InlineResponse400 from '../model/InlineResponse400';
import InlineResponse401 from '../model/InlineResponse401';
import InlineResponse500 from '../model/InlineResponse500';

/**
* Admin service.
* @module api/AdminApi
* @version 1.0
*/
export default class AdminApi {

    /**
    * Constructs a new AdminApi. 
    * @alias module:api/AdminApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }



    /**
     * Delete an application
     * @param {String} authorization Bearer Token Authentication
     * @param {String} app The name of the application
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2003} and HTTP response
     */
    deleteAppByAdminWithHttpInfo(authorization, app) {
      let postBody = null;
      // verify the required parameter 'authorization' is set
      if (authorization === undefined || authorization === null) {
        throw new Error("Missing the required parameter 'authorization' when calling deleteAppByAdmin");
      }
      // verify the required parameter 'app' is set
      if (app === undefined || app === null) {
        throw new Error("Missing the required parameter 'app' when calling deleteAppByAdmin");
      }

      let pathParams = {
        'app': app
      };
      let queryParams = {
      };
      let headerParams = {
        'Authorization': authorization
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2003;
      return this.apiClient.callApi(
        '/admin/apps/{app}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete an application
     * @param {String} authorization Bearer Token Authentication
     * @param {String} app The name of the application
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2003}
     */
    deleteAppByAdmin(authorization, app) {
      return this.deleteAppByAdminWithHttpInfo(authorization, app)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete a single database
     * @param {String} authorization Bearer Token Authentication
     * @param {String} db Name of the database
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2003} and HTTP response
     */
    deleteDbByAdminWithHttpInfo(authorization, db) {
      let postBody = null;
      // verify the required parameter 'authorization' is set
      if (authorization === undefined || authorization === null) {
        throw new Error("Missing the required parameter 'authorization' when calling deleteDbByAdmin");
      }
      // verify the required parameter 'db' is set
      if (db === undefined || db === null) {
        throw new Error("Missing the required parameter 'db' when calling deleteDbByAdmin");
      }

      let pathParams = {
        'db': db
      };
      let queryParams = {
      };
      let headerParams = {
        'Authorization': authorization
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2003;
      return this.apiClient.callApi(
        '/admin/dbs/{db}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete a single database
     * @param {String} authorization Bearer Token Authentication
     * @param {String} db Name of the database
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2003}
     */
    deleteDbByAdmin(authorization, db) {
      return this.deleteDbByAdminWithHttpInfo(authorization, db)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete a single user
     * @param {String} authorization Bearer Token Authentication
     * @param {String} userEmail Email ID of the user
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2003} and HTTP response
     */
    deleteUserByAdminWithHttpInfo(authorization, userEmail) {
      let postBody = null;
      // verify the required parameter 'authorization' is set
      if (authorization === undefined || authorization === null) {
        throw new Error("Missing the required parameter 'authorization' when calling deleteUserByAdmin");
      }
      // verify the required parameter 'userEmail' is set
      if (userEmail === undefined || userEmail === null) {
        throw new Error("Missing the required parameter 'userEmail' when calling deleteUserByAdmin");
      }

      let pathParams = {
        'userEmail': userEmail
      };
      let queryParams = {
      };
      let headerParams = {
        'Authorization': authorization
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2003;
      return this.apiClient.callApi(
        '/admin/users/{userEmail}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete a single user
     * @param {String} authorization Bearer Token Authentication
     * @param {String} userEmail Email ID of the user
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2003}
     */
    deleteUserByAdmin(authorization, userEmail) {
      return this.deleteUserByAdminWithHttpInfo(authorization, userEmail)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Fetch a single application
     * @param {String} authorization Bearer Token Authentication
     * @param {String} app The name of the application
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2002} and HTTP response
     */
    fetchAppByAdminWithHttpInfo(authorization, app) {
      let postBody = null;
      // verify the required parameter 'authorization' is set
      if (authorization === undefined || authorization === null) {
        throw new Error("Missing the required parameter 'authorization' when calling fetchAppByAdmin");
      }
      // verify the required parameter 'app' is set
      if (app === undefined || app === null) {
        throw new Error("Missing the required parameter 'app' when calling fetchAppByAdmin");
      }

      let pathParams = {
        'app': app
      };
      let queryParams = {
      };
      let headerParams = {
        'Authorization': authorization
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2002;
      return this.apiClient.callApi(
        '/admin/apps/{app}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Fetch a single application
     * @param {String} authorization Bearer Token Authentication
     * @param {String} app The name of the application
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2002}
     */
    fetchAppByAdmin(authorization, app) {
      return this.fetchAppByAdminWithHttpInfo(authorization, app)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Fetch all applications with/without a filter defined by query params
     * @param {String} authorization Bearer Token Authentication
     * @param {Object} opts Optional parameters
     * @param {String} opts.name Name of the application
     * @param {String} opts.owner Owner of the application
     * @param {module:model/String} opts.language Language in which the application is written
     * @param {String} opts.dockerImage Docker Image used in building the application's container
     * @param {String} opts.hostIp IPv4 address of the host machine in which the application is deployed
     * @param {String} opts.gitUrl Application's Git Repository URL
     * @param {String} opts.containerPort Port assigned by the host machine to the application's docker container
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2002} and HTTP response
     */
    fetchAppsByAdminWithHttpInfo(authorization, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'authorization' is set
      if (authorization === undefined || authorization === null) {
        throw new Error("Missing the required parameter 'authorization' when calling fetchAppsByAdmin");
      }

      let pathParams = {
      };
      let queryParams = {
        'name': opts['name'],
        'owner': opts['owner'],
        'language': opts['language'],
        'docker_image': opts['dockerImage'],
        'host_ip': opts['hostIp'],
        'git_url': opts['gitUrl'],
        'container_port': opts['containerPort']
      };
      let headerParams = {
        'Authorization': authorization
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2002;
      return this.apiClient.callApi(
        '/admin/apps', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Fetch all applications with/without a filter defined by query params
     * @param {String} authorization Bearer Token Authentication
     * @param {Object} opts Optional parameters
     * @param {String} opts.name Name of the application
     * @param {String} opts.owner Owner of the application
     * @param {module:model/String} opts.language Language in which the application is written
     * @param {String} opts.dockerImage Docker Image used in building the application's container
     * @param {String} opts.hostIp IPv4 address of the host machine in which the application is deployed
     * @param {String} opts.gitUrl Application's Git Repository URL
     * @param {String} opts.containerPort Port assigned by the host machine to the application's docker container
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2002}
     */
    fetchAppsByAdmin(authorization, opts) {
      return this.fetchAppsByAdminWithHttpInfo(authorization, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Fetch a single database
     * @param {String} authorization Bearer Token Authentication
     * @param {String} db Name of the database
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2006} and HTTP response
     */
    fetchDbByAdminWithHttpInfo(authorization, db) {
      let postBody = null;
      // verify the required parameter 'authorization' is set
      if (authorization === undefined || authorization === null) {
        throw new Error("Missing the required parameter 'authorization' when calling fetchDbByAdmin");
      }
      // verify the required parameter 'db' is set
      if (db === undefined || db === null) {
        throw new Error("Missing the required parameter 'db' when calling fetchDbByAdmin");
      }

      let pathParams = {
        'db': db
      };
      let queryParams = {
      };
      let headerParams = {
        'Authorization': authorization
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2006;
      return this.apiClient.callApi(
        '/admin/dbs/{db}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Fetch a single database
     * @param {String} authorization Bearer Token Authentication
     * @param {String} db Name of the database
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2006}
     */
    fetchDbByAdmin(authorization, db) {
      return this.fetchDbByAdminWithHttpInfo(authorization, db)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Fetch all databases with/without a filter defined by query params
     * @param {String} authorization Bearer Token Authentication
     * @param {Object} opts Optional parameters
     * @param {String} opts.name Name of the database
     * @param {String} opts.user User of the database
     * @param {String} opts.owner Owner of the database
     * @param {module:model/String} opts.language Type of the database
     * @param {String} opts.hostIp IPv4 address of the host machine in which the database is deployed
     * @param {String} opts.containerPort Port assigned by the host machine to the database's docker container
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2006} and HTTP response
     */
    fetchDbsByAdminWithHttpInfo(authorization, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'authorization' is set
      if (authorization === undefined || authorization === null) {
        throw new Error("Missing the required parameter 'authorization' when calling fetchDbsByAdmin");
      }

      let pathParams = {
      };
      let queryParams = {
        'name': opts['name'],
        'user': opts['user'],
        'owner': opts['owner'],
        'language': opts['language'],
        'host_ip': opts['hostIp'],
        'container_port': opts['containerPort']
      };
      let headerParams = {
        'Authorization': authorization
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2006;
      return this.apiClient.callApi(
        '/admin/dbs', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Fetch all databases with/without a filter defined by query params
     * @param {String} authorization Bearer Token Authentication
     * @param {Object} opts Optional parameters
     * @param {String} opts.name Name of the database
     * @param {String} opts.user User of the database
     * @param {String} opts.owner Owner of the database
     * @param {module:model/String} opts.language Type of the database
     * @param {String} opts.hostIp IPv4 address of the host machine in which the database is deployed
     * @param {String} opts.containerPort Port assigned by the host machine to the database's docker container
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2006}
     */
    fetchDbsByAdmin(authorization, opts) {
      return this.fetchDbsByAdminWithHttpInfo(authorization, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Fetch bind addresses(IP:Port) of a single microservice on all nodes
     * @param {String} authorization Bearer Token Authentication
     * @param {module:model/String} type Type of microservice
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2009} and HTTP response
     */
    fetchNodeByAdminWithHttpInfo(authorization, type) {
      let postBody = null;
      // verify the required parameter 'authorization' is set
      if (authorization === undefined || authorization === null) {
        throw new Error("Missing the required parameter 'authorization' when calling fetchNodeByAdmin");
      }
      // verify the required parameter 'type' is set
      if (type === undefined || type === null) {
        throw new Error("Missing the required parameter 'type' when calling fetchNodeByAdmin");
      }

      let pathParams = {
        'type': type
      };
      let queryParams = {
      };
      let headerParams = {
        'Authorization': authorization
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2009;
      return this.apiClient.callApi(
        '/admin/nodes/{type}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Fetch bind addresses(IP:Port) of a single microservice on all nodes
     * @param {String} authorization Bearer Token Authentication
     * @param {module:model/String} type Type of microservice
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2009}
     */
    fetchNodeByAdmin(authorization, type) {
      return this.fetchNodeByAdminWithHttpInfo(authorization, type)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Fetch bind addresses(IP:Port) of all microservices on all nodes
     * @param {String} authorization Bearer Token Authentication
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2008} and HTTP response
     */
    fetchNodesByAdminWithHttpInfo(authorization) {
      let postBody = null;
      // verify the required parameter 'authorization' is set
      if (authorization === undefined || authorization === null) {
        throw new Error("Missing the required parameter 'authorization' when calling fetchNodesByAdmin");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
        'Authorization': authorization
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2008;
      return this.apiClient.callApi(
        '/admin/nodes', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Fetch bind addresses(IP:Port) of all microservices on all nodes
     * @param {String} authorization Bearer Token Authentication
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2008}
     */
    fetchNodesByAdmin(authorization) {
      return this.fetchNodesByAdminWithHttpInfo(authorization)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Fetch a single user
     * @param {String} authorization Bearer Token Authentication
     * @param {String} userEmail Email ID of the user
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2007} and HTTP response
     */
    fetchUserByAdminWithHttpInfo(authorization, userEmail) {
      let postBody = null;
      // verify the required parameter 'authorization' is set
      if (authorization === undefined || authorization === null) {
        throw new Error("Missing the required parameter 'authorization' when calling fetchUserByAdmin");
      }
      // verify the required parameter 'userEmail' is set
      if (userEmail === undefined || userEmail === null) {
        throw new Error("Missing the required parameter 'userEmail' when calling fetchUserByAdmin");
      }

      let pathParams = {
        'userEmail': userEmail
      };
      let queryParams = {
      };
      let headerParams = {
        'Authorization': authorization
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2007;
      return this.apiClient.callApi(
        '/admin/users/{userEmail}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Fetch a single user
     * @param {String} authorization Bearer Token Authentication
     * @param {String} userEmail Email ID of the user
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2007}
     */
    fetchUserByAdmin(authorization, userEmail) {
      return this.fetchUserByAdminWithHttpInfo(authorization, userEmail)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Fetch all users with/without a filter defined by query params
     * @param {String} authorization Bearer Token Authentication
     * @param {Object} opts Optional parameters
     * @param {String} opts.username Name of the user
     * @param {String} opts.email Email of the user
     * @param {Boolean} opts.isAdmin Field denoting superuser privileges
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/InlineResponse2007} and HTTP response
     */
    fetchUsersByAdminWithHttpInfo(authorization, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'authorization' is set
      if (authorization === undefined || authorization === null) {
        throw new Error("Missing the required parameter 'authorization' when calling fetchUsersByAdmin");
      }

      let pathParams = {
      };
      let queryParams = {
        'username': opts['username'],
        'email': opts['email'],
        'is_admin': opts['isAdmin']
      };
      let headerParams = {
        'Authorization': authorization
      };
      let formParams = {
      };

      let authNames = ['bearerAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = InlineResponse2007;
      return this.apiClient.callApi(
        '/admin/users', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Fetch all users with/without a filter defined by query params
     * @param {String} authorization Bearer Token Authentication
     * @param {Object} opts Optional parameters
     * @param {String} opts.username Name of the user
     * @param {String} opts.email Email of the user
     * @param {Boolean} opts.isAdmin Field denoting superuser privileges
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/InlineResponse2007}
     */
    fetchUsersByAdmin(authorization, opts) {
      return this.fetchUsersByAdminWithHttpInfo(authorization, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


}
